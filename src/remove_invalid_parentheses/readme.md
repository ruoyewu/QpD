### Question

Remove the minimum number of invalid parentheses in order to make the input string valid. Return all possible results.

**Note:** The input string may contain letters other than the parentheses `(` and `)`.

**Example 1:**

```
Input: "()())()"
Output: ["()()()", "(())()"]
```

**Example 2:**

```
Input: "(a)())()"
Output: ["(a)()()", "(a())()"]
```

**Example 3:**

```
Input: ")("
Output: [""]
```

### Solution

要移除这串括号的某几个，使得这是一个有效的括号串，所谓有效的括号串，就是指在任何一个位置，左括号的数量大于等于右括号的数量，且对于整个括号串而言，左括号数量等于右括号数量，如`(())()`、`()()`是有效的，`)()`、`()())`是无效的。也就是说，在任何一个位置，只要右括号数量大于左括号了，那么这段必然是无效的，但是对于左括号数量大于右括号的情况，只能在遍历完整个数组之后才能确定。

对于第一种情况，括号串`())`，遍历到第二个`')'`的时候，可以判断这是一个无效括号串，此时应该如何对其进行修正？将多余的`')'`去掉即可，去掉一个`')'`之后，变成了`()`，这时`())`就变成了`()`，结束。那么同样地，对于`()())`，遍历到第三个`')'`时，得出`')'`多余，应该去掉一个，又因为要求出所有可能的解，也就是说，对于有多个可移除的`')'`，都要移除一遍，才能得到所有的结果。

那么是不是所有的`')'`都是可以移除的？因为在每一个位置左括号的数量都是大于右括号数量的，所以移除了任意一个`')'`，前面的条件肯定是依旧满足的，所以必然不会出现移除了某个`')'`之后使得前面的某个位置导致括号串变成无效。

是不是所有的`')'`都应该移除一遍？比如上面的例子`()())`，移除第一个`')'`，变成`(())`，移除第二个变成`()()`，移除第三个也是`()()`，普遍的，所有的连续的右括号，移除之后的结果肯定都是一样的，也就是说，对于连续的`')'`，只需要移除其中一个即可。

那么就有`()())`修正后有两种结果：`()()`和`(())`。

再看一个例子，`()())())`，第一次，遇到第三个`')'`，需要修正，变成了`....())`。然后又遇到了第四个`')'`，需要修正成`....()`，这样一种，多段无效的该如何解？

可采用分支求解。

