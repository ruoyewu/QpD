There are two sorted arrays **nums1** and **nums2** of size m and n respectively.

Find the median of the two sorted arrays. The overall run time complexity should be O(log (m+n)).

**Example 1:**

```
nums1 = [1, 3]
nums2 = [2]

The median is 2.0
```

**Example 2:**

```
nums1 = [1, 2]
nums2 = [3, 4]

The median is (2 + 3)/2 = 2.5
```

### Solution

#### 二分法

首先，题目是要求两个有序数组整合在一起的中位数，那么首先看一下对于一个有序数组来说，怎么求中位数，如有：

```
A = [1, 2, 3, 4, 5]
B = [1, 2, 3, 4]
```

这两个有序数组，对于 A 来说，有中位数 3 ，对于 B 来说，有中位数 (2 + 3) / 2 = 2.5 ，这就是中位数的两种情况，偶数个元素和奇数个元素。但是针对这两种情况，总不能分开讨论，要寻求它们的共同点，使得对于这两种情况来说，都能够使用同一种方法解决求中位数的问题。

下面提出一个概念，“划分” ，假设 i 是数组 A 的中位数的划分，那么数组 A 就会以 i 为中介，将自身分散成两个子数组，如一个划分 3 ，将 A 分成数组：

```java
A1 = [1, 2, 3]
A2 = [4, 5]
```

这样。

那么在求一个数组中位数的过程中，可求出某个划分，有：
$$
i = 
\begin{cases}
len(A) / 2 & len(A) \% 2 = 0 \\
(len(A) + 1) / 2 & len(A) \% 2 = 1
\end{cases}
$$
那么，对于上述的这个划分来说，就有：
$$
median = \begin{cases}
(A[i] + A[i - 1]) / 2 & len(A) \% 2 = 0 \\
A[i - 1] & len(A) \% 2 = 1
\end{cases}
$$
那么，基于上述的理论，就有下面的结果：

$i = (len(A) + 1) / 2$，因为当 $len(A)$ 为偶数的时候，先加个 1 再除以 2 得到的是同样的结果。所以根据这个 i 可以很轻松的得到单个有序数组的中位数。那么对于两个有序的数组，也可以使用相同的理论：

对于两个有序数组 A 和 B 来说，假设他们都有一个划分 i 和 j ，将 A 和 B 各划分成两个子数组：

```java
A1 = {0...i-1}
A2 = {i...}
B1 = {0...j-1}
B2 = {j...}
```

那么肯定存在这样的两个划分 i 和 j ，假设下面的 + 代表两个数组的元素相加且排序，有：

```java
C1 = A1 + B1
C2 = A2 + B2
C = A + B
```

使得 C1 和 C2 是能够用于求 C 的中位数的一个划分，那么就可以得到：

```java
C1 = {...max{A[i-1], B[j-1]}} // 即 C1 中最大的数字为 max{A[i - 1], B[j - 1]}
C2 = {min{A[i], B[j]}...} // 即 C2 中最小的数字为 min{A[i], B[j]}
```

那么根据上述的 2 式中计算中位数的公式就可以得到：

```java
mLeft = max{A[i - 1], B[j - 1]} = max{C1}
mRight = min{A[i], B[j]} = min{C2}

if (len(C) % 2 == 0) {
    median = mLeft
}else {
    median = (mLeft + mRight) / 2
}
```

由此便可以得到求两个有序数组的方法，即找到 A 和 B 的在上述情况下的 i 和 j ，假设 A 和 B 的元素个数分别是 m 和 n ，根据上面的对于单数组求中位数的推导有：

```java
i + j = (m + n + 1) / 2
```

其中 i 和 j 分别是 A 和 B 的划分，那么有 i 和 j 的范围分别是：

```java
i = [0, m]
j = [0, n]
```

那么，下面的工作就是找到这两个划分 i 和 j ，而又因为它们的和值是一个确定的，所以只需要设其中一个为变量，另一个则变成了因变量，如有：

```java
j = (m + n + 1) / 2 - i
```

但是其中有一点很重要，因为在这个环境中，j 是非负数，所以`(m + n + 1) / 2 - i`不能是负数，而前面的`(m + n + 1) /2`相对于两个固定的数组而言是一个常数，这个值取决于 i 的值，而 i 的范围是`[0, m]`，故当 i 最大时，有`(m + n + 1) / 2 - m = (n - m + 1) / 2 >= 0`，所以有`(n - m) >= -1`，所以，为了满足这个条件，求解的时候需要规定`len(A) <= len(B)`即`m <= n`才行。

那么接下来接可以将 i 的值取在`[0, m]`的范围内看是否满足求中位数的条件，而在 i 和 j 取了固定的值之后，有三种情况：

1.  `A[i - 1] > B[j]`

    这种情况即划分后的 A 左部的某个值大于了 B 的右部，说明此时在 A 上的划分太靠后，所以需要将划分前移，即需要将 i 减小，

2.  `B[j - 1] > A[i]`

    这种情况为划分后的 B 的左部的某个值大于了 A 的右部，与上相犯，需要增加 i 的值。

    那么问题来了，如果在第 2 中情况下 i 增加变成了第 1 种情况，而在第 1 种情况下 i 减小变成了第 2 种情况怎么办，一种解决方法就是，缩减 i 的取值范围。见下面。

3.  其他情况

上面的推导有 i 的取值范围是`[0, m]`，这显然是 i 的一个最宽泛的取值范围，并且可能会导致上面说的那种情况发生，那么就需要在计算 i 的确切值的过程中逐步缩减 i 的范围，使得 i 的值不会反复在 1 和 2 方式中死循环。那么我们可以确定一个 i 的范围：

```java
min = 0, max = m // 这是初始的 i 的范围
i = [min, max]
```

然后在重写上面的情况：

1.  `A[i - 1] > B[j] && i > min`

    这种情况即划分后的 A 左部的某个值大于了 B 的右部，说明此时在 A 上的划分太靠后，所以需要将划分前移，即需要将 i 减小，所以，可以将通过将 max 减小的方式，间接减小改变 i 的值

2.  `B[j - 1] > A[i] && i < max`

    这种情况为划分后的 B 的左部的某个值大于了 A 的右部，与上相犯，需要增加 i 的值，而这里，通过增加 min 的值的方式，间接增加 i 的值。

    所以，如果出现了 i 在 方式 1 和方式 2 中循环的情况，上述的情况必然会在有限的循环次数里，有`i == max`或`i == min`，如此一来也意味着，已经找到了求中位数的划分。

3.  其他情况

    这里的话，就可以根据上面的公式`mLeft = max{A[i - 1], B[j - 1]}`和`mRight = min{A[i], B[j]}`求中位数了，但是这里面还有几个特殊值：

    1.  `i == 0 || j == 0`

        为了求 mLeft ，需要`A[i - 1]`和`B[j - 1]`，显然这种情况下无法求这两个值，但是试想，当`i == 0`的时候，意味着 A 的左部为空，那么就意味着 B 的左部就是它们的和 C 的左部，所以有在这种情况下有`mLeft = B[j - 1]`，而且根据等式`i + j == (m + n + 1) / 2`有，i 和 i 肯定不全为 0 ，同理当`j == 0`的时候也有相同的规则。

    2.  `i == m || j == n`

        而在求 mRight 的时候，也因为要求`A[i]`和`B[j]`使得`i == m`和`j == n`不能同时成立，同上，有当`i == m`时`mRight = B[j]`。

    3.  其他

        这里就是其他的正常情况，只需要求出 mLeft 和 mRight 就可以了。

    另外，除了上面的，这里还分为另外的两种情况，即 m + n 为奇为偶的问题，当为奇数时，根据上述推导，有`median = mLeft`，所以在这种情况下就可以直接省去求 mRight 的步骤了。

综上所述，就有了本程序的所有的思路了，将其实化成代码，就有：

```java
public static double find(int[] A, int[] B) {
    int m = A.length;
    int n = B.length;
    if (m > n) {
        return find(B, A);
    }
    
    int min = 0, max = m, half = (m + n + 1) / 2;
    while (min <= max) {
        int i = (min + max) / 2;
        int j = half - i;
        if (i < max && B[j - 1] > A[i]) {
            min ++;
        }else if (i > min && A[i - 1] > B[j]) {
            max --;
        }else {
            int left;
            if (i == 0) {
                left = B[j - 1];
            }else if (j == 0) {
                left = A[i - 1];
            }else {
                left = Math.max(A[i - 1], B[j - 1]);
            }
            if ((m + n) % 2 == 1) {
                return left;
            }
            int right;
            if (i == m) {
                right = B[j];
            }else if (j == n) {
                right = A[i];
            }else {
                right = Math.min(A[i], B[j]);
            }
            return (left + right) / 2.0;
        }
    }
    return -1;
}
```

